# 分析

- 通过分析计算每个数字应该计算的次数然后遍历即可

- 观察发现，每个数字应该计算的次数跟它的位置以及所在的子数组的长度有关

- 假设每个数都在中间则` c[i] += j;`

- 旁边的数有可能没有 `j` 次，所以分两种情况判断

  - 位于位置`i`的数字没法作为子数组的后几个元素，则

    `if (i < j) c[i] += i - j + 1;`

  - 位于位置`i`的数字没法作为子数组的前几个元素，则

    `   if (arr.length - i < j) c[i] -= j - arr.length + i;`

# 不足

感觉还有更加简单的方法，这个时间复杂度相对来说还是比较高的。以后有时间再补充。